{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "solana-adapter",
  "type": "registry:lib",
  "dependencies": [
    "gill",
    "react",
    "@gillsdk/react",
    "@tanstack/react-query"
  ],
  "registryDependencies": [
    "@wallet-kit/context",
    "@wallet-kit/network",
    "@wallet-kit/use-wallet"
  ],
  "files": [
    {
      "path": "src/registry/default/lib/chains/solana/adapter.tsx",
      "content": "\"use client\";\n\nimport {\n  GILL_HOOK_CLIENT_KEY,\n  SolanaProvider,\n  useAccount as useGillAccount,\n  useBalance as useGillBalance,\n  useLatestBlockhash as useGillLatestBlockhash,\n  useProgramAccounts as useGillProgramAccounts,\n  useSignatureStatuses as useGillSignatureStatuses,\n  useSignaturesForAddress as useGillSignaturesForAddress,\n  useSolanaClient as useGillSolanaClient,\n  useTokenAccount as useGillTokenAccount,\n  useTokenMint as useGillTokenMint,\n  useUpdateSolanaClient as useGillUpdateSolanaClient,\n} from \"@gillsdk/react\";\nimport {\n  QueryClient,\n  type QueryClient as QueryClientType,\n  useQueryClient,\n} from \"@tanstack/react-query\";\nimport {\n  type Address,\n  type Commitment,\n  createSolanaClient,\n  type SolanaClient,\n  type SolanaClientUrlOrMoniker,\n  type SolanaClusterMoniker,\n} from \"gill\";\nimport { useContext, useMemo } from \"react\";\nimport {\n  useWallet,\n  useWalletAccount,\n  useWalletNetwork,\n} from \"@/registry/default/hooks/use-wallet\";\nimport {\n  WalletUiContext,\n  type WalletUiContextValue,\n} from \"@/registry/default/lib/chains/context\";\nimport {\n  getSolanaClusterMoniker,\n  type SolanaNetworkId,\n} from \"@/registry/default/lib/chains/solana\";\n\ntype SolanaWalletProviderProps = {\n  children: React.ReactNode;\n  url?: SolanaClientUrlOrMoniker;\n  queryClient?: QueryClientType;\n};\n\ntype SolanaNetworkInfo = {\n  networkId: SolanaNetworkId;\n  cluster: SolanaClusterMoniker;\n};\n\nfunction isSolanaNetwork(networkId: string): boolean {\n  return networkId.startsWith(\"solana:\");\n}\n\nfunction createSolanaClientFromNetwork(\n  networkUrl: string,\n  customUrl?: SolanaClientUrlOrMoniker\n): SolanaClient {\n  const urlOrMoniker = customUrl ?? networkUrl;\n  return createSolanaClient({ urlOrMoniker });\n}\n\nfunction shouldInjectSolanaClient(\n  existingClient: unknown,\n  isSolana: boolean\n): boolean {\n  return isSolana && !existingClient;\n}\n\nfunction ensureSolanaQueryClient(\n  existingClient: QueryClientType\n): QueryClientType {\n  const defaultQueryFn = existingClient.getDefaultOptions().queries?.queryFn;\n\n  if (defaultQueryFn) {\n    return existingClient;\n  }\n\n  const defaultOptions = existingClient.getDefaultOptions();\n\n  return new QueryClient({\n    ...defaultOptions,\n    defaultOptions: {\n      ...defaultOptions,\n      queries: {\n        ...defaultOptions.queries,\n        queryFn: ({ queryKey }) => {\n          if (queryKey[0] === GILL_HOOK_CLIENT_KEY) {\n            throw new Error(\n              \"SolanaProvider must be present when using @gillsdk/react hooks\"\n            );\n          }\n          throw new Error(\n            `No queryFn provided for query key: ${String(queryKey[0])}`\n          );\n        },\n      },\n    },\n  });\n}\n\nfunction SolanaWalletProvider({\n  children,\n  url,\n  queryClient: queryClientProp,\n}: SolanaWalletProviderProps) {\n  const existingContext = useContext(WalletUiContext);\n  const { network } = useWalletNetwork();\n  const queryClientFromContext = useQueryClient();\n\n  const queryClient = useMemo(\n    () => ensureSolanaQueryClient(queryClientProp ?? queryClientFromContext),\n    [queryClientProp, queryClientFromContext]\n  );\n\n  const isSolana = isSolanaNetwork(network.id);\n\n  const solanaClient = useMemo(() => {\n    if (!isSolana) {\n      return null;\n    }\n    const client = createSolanaClientFromNetwork(network.url, url);\n    queryClient.setQueryData([GILL_HOOK_CLIENT_KEY], client);\n    return client;\n  }, [isSolana, network.url, url, queryClient]);\n\n  const enhancedContext = useMemo<WalletUiContextValue<SolanaClient>>(\n    () => ({\n      ...existingContext,\n      client: (solanaClient ?? existingContext.client) as SolanaClient,\n    }),\n    [existingContext, solanaClient]\n  );\n\n  const hasSolanaClient = isSolana && solanaClient;\n  if (!hasSolanaClient) {\n    return children;\n  }\n\n  const shouldInject = shouldInjectSolanaClient(\n    existingContext.client,\n    isSolana\n  );\n\n  const providerContent = (\n    <SolanaProvider client={solanaClient} queryClient={queryClient}>\n      {children}\n    </SolanaProvider>\n  );\n\n  if (!shouldInject) {\n    return providerContent;\n  }\n\n  return (\n    <WalletUiContext.Provider value={enhancedContext}>\n      {providerContent}\n    </WalletUiContext.Provider>\n  );\n}\n\nfunction useSolanaNetwork(): SolanaNetworkInfo | null {\n  const { network } = useWalletNetwork();\n\n  if (!network) {\n    return null;\n  }\n\n  if (!isSolanaNetwork(network.id)) {\n    return null;\n  }\n\n  return {\n    networkId: network.id as SolanaNetworkId,\n    cluster: getSolanaClusterMoniker(network.id as SolanaNetworkId),\n  };\n}\n\nfunction useSolanaWallet(url?: SolanaClientUrlOrMoniker): SolanaClient {\n  const wallet = useWallet<SolanaClient>();\n  const { network } = useWalletNetwork();\n\n  const fallbackClient = useMemo(() => {\n    const urlOrMoniker = url ?? (network.url as SolanaClientUrlOrMoniker);\n    return createSolanaClient({ urlOrMoniker });\n  }, [network.url, url]);\n\n  return wallet.client ?? fallbackClient;\n}\n\nfunction createDisabledQueryResult<\n  T extends { isLoading?: boolean; isError?: boolean; error?: unknown },\n>(result: T, override?: Partial<T>): T {\n  return {\n    ...result,\n    isLoading: false,\n    isError: false,\n    error: null,\n    ...override,\n  };\n}\n\nfunction useSolanaBalance(address?: string) {\n  const { account } = useWalletAccount();\n  const solanaNetwork = useSolanaNetwork();\n  const addressToUse = address ?? account?.address ?? \"\";\n  const shouldFetch = Boolean(addressToUse && solanaNetwork);\n\n  const result = useGillBalance({\n    address: addressToUse,\n    options: {\n      enabled: shouldFetch,\n    },\n  });\n\n  if (!shouldFetch) {\n    return createDisabledQueryResult({\n      ...result,\n      balance: null,\n    });\n  }\n\n  return result;\n}\n\nfunction useSolanaAccount(address?: string) {\n  const { account } = useWalletAccount();\n  const solanaNetwork = useSolanaNetwork();\n  const addressToUse = address ?? account?.address ?? \"\";\n  const shouldFetch = Boolean(addressToUse && solanaNetwork);\n\n  const result = useGillAccount({\n    address: addressToUse,\n    options: {\n      enabled: shouldFetch,\n    },\n  });\n\n  if (!shouldFetch) {\n    return createDisabledQueryResult({\n      ...result,\n      account: null,\n    });\n  }\n\n  return result;\n}\n\nfunction useSolanaEnabled() {\n  const solanaNetwork = useSolanaNetwork();\n  return Boolean(solanaNetwork);\n}\n\nfunction useSolanaTokenAccount(\n  mint: Address,\n  owner: Address,\n  options?: {\n    commitment?: Commitment;\n  }\n) {\n  const isSolana = useSolanaEnabled();\n\n  return useGillTokenAccount({\n    mint,\n    owner,\n    options: {\n      enabled: isSolana,\n      ...options,\n    },\n  });\n}\n\nfunction useSolanaTokenMint(\n  mint: Address,\n  options?: {\n    commitment?: Commitment;\n  }\n) {\n  const isSolana = useSolanaEnabled();\n\n  return useGillTokenMint({\n    mint,\n    options: {\n      enabled: isSolana,\n      ...options,\n    },\n  });\n}\n\nfunction useSolanaProgramAccounts(\n  program: Address,\n  options?: {\n    commitment?: Commitment;\n    filters?: unknown[];\n  }\n) {\n  const isSolana = useSolanaEnabled();\n\n  return useGillProgramAccounts({\n    program,\n    options: {\n      enabled: isSolana,\n      ...options,\n    },\n  });\n}\n\nfunction useSolanaSignaturesForAddress(\n  address: Address,\n  options?: {\n    limit?: number;\n    before?: string;\n    until?: string;\n  }\n) {\n  const isSolana = useSolanaEnabled();\n\n  return useGillSignaturesForAddress({\n    address,\n    options: {\n      enabled: isSolana,\n      ...options,\n    },\n  });\n}\n\nfunction useSolanaSignatureStatuses(\n  signatures: string[],\n  options?: {\n    searchTransactionHistory?: boolean;\n  }\n) {\n  const isSolana = useSolanaEnabled();\n\n  return useGillSignatureStatuses({\n    signatures,\n    options: {\n      enabled: isSolana && signatures.length > 0,\n      ...options,\n    },\n  });\n}\n\nfunction useSolanaLatestBlockhash() {\n  const isSolana = useSolanaEnabled();\n\n  return useGillLatestBlockhash({\n    options: {\n      enabled: isSolana,\n    },\n  });\n}\n\nfunction useSolanaClient() {\n  return useGillSolanaClient();\n}\n\nfunction useUpdateSolanaClient() {\n  return useGillUpdateSolanaClient();\n}\n\nexport {\n  SolanaWalletProvider,\n  isSolanaNetwork,\n  useSolanaAccount,\n  useSolanaBalance,\n  useSolanaClient,\n  useSolanaLatestBlockhash,\n  useSolanaNetwork,\n  useSolanaProgramAccounts,\n  useSolanaSignatureStatuses,\n  useSolanaSignaturesForAddress,\n  useSolanaTokenAccount,\n  useSolanaTokenMint,\n  useSolanaWallet,\n  useUpdateSolanaClient,\n};\n",
      "type": "registry:lib",
      "target": "lib/chains/solana/adapter.tsx"
    }
  ]
}